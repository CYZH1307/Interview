## Redis
### 1.Zset的跳表
- 就是层级链表（logN）
- 相比于红黑树：支持并发，实现简单，不支持区间查找，空间消耗大
### 2.过期健的淘汰策略
- 定时删除：有利内存
- 定期删除：随机看参数
- 惰性删除：有利CPU
- 惰性删除+定期删除：Mixed
### 3.持久化
- AOF
- RDB
- AOF+RDB 
### 4.为什么Redis单线程还是快
- 大部分操作在内存完成
- 没有进程切换开销
-  I/O 多路复用机制
- CPU不是瓶颈，可能在网络带宽or内存
## HTTP
### 1.HTTP版本区别
- HTTP/0.9：仅支持GET
- HTTP/1.0：支持POST等新特性，引入Header
- HTTP/1.1：支持长链接，管线化
- HTTP/2.0：引入二进制协议，头部压缩(HPACK)，服务器推送，并发传输(Stream)
- HTTP/3.0：使用新的QUIC(无队头阻塞，更快建立连接，连接迁移)，默认TLS1.3加密
### 2.状态码
- 1xx：中间状态
- 2xx：成功
- 3xx：重定向
- 4xx：客户端错误
- 5xx：服务端错误
### 3. SSL/TLS
1. client(Client Hello)：**TLS版本号**，**密码套件列表**，**随机数1**
2. server(Server Hello)：**TLS版本号**，**随机数2**，**密码套件**（密钥交换算法，签名算法，对称加密算法，摘要算法），**CA证书**（Certificate Signature，公钥，有效时间，用途，持有者信息，CA机构信息）
  - 客户端用约定的Hash算法获取证书Hash值H1，然后用公钥解密CS得到Hash值H2，如果H1等于H2就可以确保证书的完整性
  - 然后通过证书依赖向上找到根证书，然后在本地找是否有这个根证书的依赖
3. client(Client Key Exchange)：公钥加密后的**PMS(Pre-Master Secret)**
  -  服务器拿到加密后的PMS，用私钥解密出PMS，然后用约定好的PSK算出**MS(Master Secret)**
4. client(Change Cipher Spec)：告诉服务器接下来开始加密通话(使用MS)
5. client(Encrypted Handshake Message/Finished)：验证加密通信是否可用

### 4.RSA算法
> DES的软件实现比RSA快100倍，硬件实现快1000~10 000倍，实际应用中通常结合起来用。RSA还有一个缺点就是不支持**前向保密**，ECDHE密钥协商算法解决了这个问题

**执行步骤：**
- 选择两个大素数p,q
- $n = p * q$
- $z = (p - 1) * (q - 1)$
- $z = n - p - q + 1,n > z$
- 取$e < n$, 使$gcd(e, z) = 1$
- 求$d$使$ed \equiv 1 \pmod z$
- 公钥:`(n,e)`,密钥:`(n,d)`
- $m^{e*d} \equiv m^{e*d \pmod z} \equiv m^1 \pmod n$ (这里详细证明就不写了)

**加密m：**
- A（公钥），B（有公钥，私钥）
- A，求出$c \equiv m^e \pmod n$, (用公钥加密)， 发送c
- B得到c，求出$m \equiv c^d \pmod n$,(用私钥钥解密)


### 5.Cookie和Session
- Cookie是存储在用户浏览器上的小段文本信息，主要用于跟踪用户状态，如登录信息，购物车信息等。
- Session是存储在服务器端的信息，用于跟踪用户状态。Session ID通常存储在cookie中，以便于服务器识别特定的用户。

## TCP/UDP
### 1.三次挥手
- c：SYN
- s：SYN+1，ACK
- c：ACK
### 2.四次握手
- c：FIN
- s：ACK
- s：FIN
- c：ACK
### 3.拥塞控制
- 慢启动
- 快速恢复
- 拥塞避免
### 4.QUIC
- 快速建立连接：采用0-RTT连接建立方式，可以在一次往返时延内建立连接
- 支持多路复用：可以在一个连接上传输多个数据流
- 支持移动设备：QUIC对移动设备的网络环境进行优化，降低网络丢包率和延迟
- 集成可靠性和安全性：流控制，拥塞控制，TLS等



## IP
### 1.ARP
- 源MAC地址是什么：发送ARP请求的主机的MAC地址
- 目的MAC地址是什么：请求的目标主机的MAC地址
- 怎么找到目的MAC地址：当目标主机接收到ARP请求时，它会检查请求中的IP地址是否与自己的IP地址匹配。如果匹配，它将向发送主机发送一个ARP响应，响应包含目标主机的MAC地址。

## MySQL
### 1.MVCC
- 多版本并发控制(Multi-Version Concurrency Control)
- 为每一个事务创建一个Read View，反映事务启动时的状态
- 避免了锁的使用
- 使用回滚日志(undo log)实现

### 2.回表和覆盖索引
- 先定位主键，然后定位资源就是回表
- 覆盖锁引是指无需回表直接就可以得到所需资源

### 3.前缀索引
- 类似于tire树，一个字母一个节点

### 4.B+树
- 数据全部在叶子节点
- 叶子节点上的数据使用双链表相连
- 树的高度低，减少I/O

### 5.死锁
>死锁的4个必要条件：互斥、占有且等待、不可强占用、循环等待 
- 开启死锁检测
- 设置事务等待锁超时时间
- 资源有序法来防止死锁

### 6.间隙锁(Gap Lock)
- Gap Lock之间没有互斥关系

### 7.快照读/当前读
>两种读取数据的方式，快照读是读取事务开始时的快照数据，当前读是读取当前最新数据，当前读可以分为共享锁读和排他锁读

### 8.如何用 Redis 实现分布式锁的？
- SET命令中有个NX参数可以满足key不存在时插入
  - 如果key插入成功，表示加锁成功
  - 反之，表示加锁失败
- 在SET命令执行时加上EX/PX选项，设置过期时间
- 给每个客户端设置一个唯一值来区别客户端

```MySQL
SET lock_key 8848 NX PX 10000 
```
> 给客户端8848设置一个10s的锁


## 操作系统
### 1.段页式存储特点，用到了什么寄存器
### 2. kill一个线程发生了什么
### 3.什么是软中断，什么是硬中断
### 4.进程间通信
### 5.进程调度策略
### 6.DMA(Direct Memory Access)
> 在进行I/O设备和内存的数据传输时候，数据搬运的工作全部交给DMA控制器，CPU不再参与任何与数据搬运相关事情

### 7.零拷贝(Zero-copy)
> 没有通过CPU来拷贝数据，所有数据都是DMA来进行传输到
```cpp
// mmap + write 
buf = mmap(file, len);
write(sockfd, buf, len);

// sendfile
sendfile(file, sockfd, offset, len); //offset 偏移量
```
>使用sendfile少一次系统调用，少两次上下文切换，但是还是有三次拷贝：
1. DMA拷贝：磁盘 -> 缓存区
2. CPU拷贝：缓存区 -> socket缓存区
3. DMA拷贝：socket缓冲区 -> 网卡
如果使用SG-DMA技术，那么2、3步可以由SG-DMA控制器将内核缓存区拷贝到网卡中，从而实现零拷贝


## C++
### 1.关键字
1. static：静态变量，作用域为所在文件夹
2. virtual：用于实现多态，虚函数可以被子类函数改写
3. new/delete：用于动态内存管理
4. extern：用于声明外部变量或函数，表示该变量或函数定义在其他文件中
5. explicit：用于显式声明构造函数，防止隐式类型转换。
6. volatile：表示该变量是易变的，可能被意外修改，需要在每次使用时重新获取。
7. noexcept：函数说明符，用于指示一个函数不会引发异常
8. constexpr：指示一个表达式可以在编译时计算出结果
9. override：用于标识一个成员函数将覆盖基类的虚函数
10. final：用于防止类的派生类重载虚函数
11. `[[nodiscard]]`: 用于警告忽略函数或类的返回值可能是错误的
12. `[[maybe_unused]]`: 用于指示声明的变量、参数或函数可能未被使用，从而消除未使用的警告
13. if constexpr: 用于在编译时进行条件检查。只有满足条件的分支会被编译



### 2.折叠表达式
> C++17新引入的语法
```cpp
template<typename... Args>
auto sum(int op, Args... args) noexcept
{
    if(op == 0) return (args + ...);
    else if(op == 1) return (args - ...);
    
    return (args, ...);
}

int main()
{
    std::cout << sum(0, 1, 2, 3, 4, 5) << std::endl; // 输出15
    std::cout << sum(1, 1, 2, 3, 4, 5) << std::endl; // 输出3, 1 - 2 + 3 - 4 + 5
    std::cout << sum(1000, 1, 2, 3, 4, 5) << std::endl; // 输出5，逗号表达式语法
    return 0;
}
```
### 3.亡值
> 在C++中，亡值是一个临时的、无名的值，或者是对即将被销毁的对象的引用。亡值在表达式求值后就不再存在。它们通常出现在赋值运算符的右侧，或者作为函数的返回值。

1. **亡值引用（Rvalue Reference）是什么？**
    亡值引用是C++11引入的一种新的引用类型，用于绑定到亡值。亡值引用通常用于实现移动语义和完美转发。亡值引用的声明方式是在类型后面加两个ampersand（&&），例如`int&&`。

### 4.虚函数
1. **什么是虚函数？**
    虚函数是一种特殊的成员函数，它在基类中被声明为`virtual`，并且在派生类中可以被重写。虚函数允许我们通过基类指针或引用来调用派生类的函数，这是实现多态的一种方式。
2. **如何声明和使用虚函数？**
    在函数的声明前加上关键字`virtual`就可以将一个函数声明为虚函数。如果一个类的函数被声明为虚函数，那么在它的派生类中，同名同参数的函数默认也是虚函数。
3. **什么是纯虚函数？**
    纯虚函数是没有定义（也就是没有实现）的虚函数。在函数的声明后加上`= 0`就可以将一个虚函数声明为纯虚函数。包含纯虚函数的类称为抽象类，不能被实例化。
4. **虚函数表是什么？**
    虚函数表（也称为vtable）是一个存储虚函数地址的表。每一个有虚函数的类，或者从有虚函数的类派生的类，都有一个虚函数表。虚函数表使得在运行时可以动态地确定应该调用哪个函数，从而实现多态。
5. **如何覆盖虚函数？**
    覆盖虚函数只需在派生类中提供一个与基类虚函数同名同参数的函数，这个函数会自动覆盖基类中的虚函数。从C++11开始，你可以使用`override`关键字来显式地指示一个函数是覆盖的虚函数，如果你错误地声明了一个覆盖函数，编译器会给出错误。

### 5.RAII机制
1. **什么是RAII，为什么我们需要使用它？**
    RAII是一种在C++中管理资源（如内存，文件句柄，网络连接等）的技术。在RAII中，我们将资源的生命周期与对象的生命周期绑定，当对象被创建时，资源被获取；当对象被销毁时，资源被释放。这使得我们可以在异常发生时，还能保证资源的正确释放。
2. **如何在C++中实现RAII？**
    创建一个类，其构造函数获取资源，析构函数释放资源。当我们创建该类的对象时，资源被获取；当对象离开其作用域时，资源被自动释放。
3. **RAII如何处理异常安全？**
    RAII通过将资源的释放放在析构函数中，确保即使在发生异常时，资源也能被正确释放。这是因为在C++中，一旦异常被抛出，所有在当前作用域内的对象都会被析构。
4. **RAII有什么缺点或限制？**
    RAII的一个潜在问题是，如果资源的生命周期不适合绑定到单个对象，或者需要在多个对象之间共享，则可能难以正确使用RAII。在这种情况下，你可能需要使用例如智能指针之类的工具来管理资源。
5. **什么是智能指针，它们如何与RAII关联？**
    智能指针是一种实现RAII的工具，它们在内部管理一个动态分配的对象。当智能指针被销毁（例如离开其作用域）时，它们会自动删除或释放其内部的对象。C++标准库提供了几种类型的智能指针，如`std::unique_ptr`，`std::shared_ptr`和`std::weak_ptr`。

### 6.C++动态多态的实现
> 动态多态是通过虚函数来实现的，基类中的函数被声明为虚函数就可以被子类改写，通过基类指针指向实际的子类类型确定函数的实际类型被称为动态多态。C++11中override可以保证子类函数是一个改写函数。
### 7.C++设计模式
1. **什么是设计模式，为什么它们在C++中很重要？**
    设计模式是在软件设计中常见问题的通用、可重用的解决方案。它们在C++中很重要，因为它们能帮助开发者编写可维护、可扩展和可重用的代码。
2. **请列举一些常见的C++设计模式，并简要解释它们的作用。**
    常见的设计模式包括：单例模式（确保一个类只有一个实例，并提供全局访问点），工厂模式（创建对象时，不会对客户端暴露创建逻辑），观察者模式（在对象之间建立一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象）等。
3. **如何在C++中实现单例模式？**
    在C++中实现单例模式通常需要私有化其构造函数，并提供一个静态方法来获取唯一的实例。
4. **策略模式在C++中是如何实现的？**
    策略模式在C++中通常通过定义一个策略接口，并提供多个实现该接口的类来实现。客户端代码可以根据需要选择和使用不同的策略。
5. **什么是适配器模式，它在C++中如何使用？**
    适配器模式是一种结构模式，可以让不兼容的接口能够相互合作。在C++中，你可以创建一个新的类，它包含有你想要适配的类的实例，然后在新类中创建新的接口方法，这些方法内部会调用到被适配的类的方法。

### 8.C++的四种类型转换
1. **`static_cast`是什么，它如何使用？**
    `static_cast`是最通用的类型转换工具，它可以在各种不同类型之间进行转换，包括基本数据类型、指针、引用等。但是，它不执行运行时类型检查，因此可能存在一定的风险。
2. **`dynamic_cast`是什么，它如何使用？**
    `dynamic_cast`主要用于在类层次结构中进行安全的向下转型。它在运行时检查转换是否有效，如果无效，它会返回空指针（对于指针类型）或抛出异常（对于引用类型）。
3. **`const_cast`是什么，它如何使用？**
    `const_cast`用于移除常量性。它可以将`const`类型转换为非`const`类型，或者将`volatile`类型转换为非`volatile`类型。
4. **`reinterpret_cast`是什么，它如何使用？**
    `reinterpret_cast`用于进行低级别的类型转换。它可以在任意两种类型之间进行转换，但结果可能依赖于特定的平台和编译器。因此，除非你非常清楚自己在做什么，否则应该尽量避免使用`reinterpret_cast`。

### 9.C++的内存模型
1. **C++内存模型是什么？**
    C++内存模型定义了对象、内存位置、线程、指令序列等的概念，以及它们如何相互交互。它是理解多线程程序行为和同步原语（如互斥锁和原子操作）如何工作的基础。
2. **C++内存模型中的对象是什么？**
    在C++内存模型中，对象是内存中的一个区域，它有一个类型，并且可以包含值。对象的生命周期从创建（初始化）开始，到销毁结束。
3. **C++内存模型中的内存位置是什么？**
    C++内存模型中的内存位置是一个对象或者一个标量类型的一部分。每个内存位置都可以独立地存储和加载。
4. **C++中的线程和指令序列是什么？**
    在C++中，线程是指令序列的执行者。指令序列是由表达式和语句产生的一系列指令，它定义了程序的执行流。
5. **C++内存模型如何处理多线程程序中的同步问题？**
    C++内存模型通过定义原子操作、互斥锁、内存顺序、顺序点等概念，来处理多线程程序中的同步问题。例如，原子操作可以保证在多线程程序中，对一个内存位置的读写操作不会被其他线程打断。


## Kafka
### 1.如何保证不会重复消费
### 2.消费组结构
### 3.零拷贝
### 4.滚动策略
### 5.高可靠性

## Kubernetes


## 分布式系统
### 1.CAP