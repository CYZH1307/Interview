### 0901号
#### 写缓存 
>写缓存通常实现为一个字节缓冲区，可以在其中添加要发送的数据，然后在适合的时机将其一次性写入网络。

1. **数据丢失**：如果系统在数据被从写缓存写入最终存储介质之前发生崩溃，那么写缓存中的数据可能会丢失。为了避免这个问题，可以使用如日志（Logging）或事务（Transaction）这样的持久性机制。这些机制可以确保即使在系统崩溃后，也可以从日志或事务中恢复数据。
    
2. **数据一致性**：当多个进程或线程都在使用写缓存时，可能会出现数据一致性问题。例如，一个进程可能在写入一部分数据后被中断，然后另一个进程开始写入数据，这可能导致最终的数据是不一致的。解决这个问题的一种方法是使用锁或其他同步机制来确保在任何时候只有一个进程可以向写缓存中写入数据。
    
3. **写入延迟**：虽然写缓存可以提高写操作的效率，但它也会引入写入延迟，因为数据需要先写入缓存，然后再从缓存写入到最终的存储介质。对于需要实时或近实时写入的应用，这可能是一个问题。解决这个问题的一种方法是使用直接写入（Direct Write）或写通（Write-Through）策略，即直接将数据写入到最终的存储介质，而不使用写缓存。或者，可以调整写缓存的刷新策略，例如使用更频繁的刷新或者在数据到达一定量时立即刷新。


### 0902号

### 0903号

### 0904号

#### 内存屏障
> 在C++中内存屏障是用`std::atomic`和`std::memory_order`枚举类型实现的。

### 0905号

#### 零拷贝
> 尽可能避免数据复制的技术。在数据传输或者读写过程中，常规的数据处理需要在用户空间和内核空间之间复制数据

##### 服务器发送场景
以下是发送文件的几种不同方法的简单描述：
1. **不使用零拷贝技术：**
```c
// 打开文件
int fd = open("file.txt", O_RDONLY);
char buffer[BUF_SIZE];

// 从磁盘读取文件到内核缓冲区，然后从内核缓冲区复制数据到用户空间
ssize_t numRead = read(fd, buffer, BUF_SIZE);

// 将数据从用户空间复制到内核缓冲区，然后发送数据到网络
ssize_t numWritten = write(sockfd, buffer, numRead);
```
2. **使用mmap：**
```c
// 打开文件
int fd = open("file.txt", O_RDONLY);
struct stat sb;
fstat(fd, &sb);

// 映射文件到内存
char *buffer = mmap(NULL, sb.st_size, PROT_READ, MAP_PRIVATE, fd, 0);

// 从内核缓冲区直接发送数据到网络
ssize_t numWritten = write(sockfd, buffer, sb.st_size);

// 解除内存映射
munmap(buffer, sb.st_size);
```
3. **使用sendfile：**
```c
// 打开文件
int in_fd = open("file.txt", O_RDONLY);
struct stat stat_buf;
fstat(in_fd, &stat_buf);
off_t file_size = stat_buf.st_size;

// 使用sendfile()将数据从磁盘直接发送到网络
ssize_t num_sent = sendfile(sockfd, in_fd, NULL, file_size);
```
4. **使用DMA（Direct Memory Access）**：是一种允许硬件子系统（比如网络卡，磁盘控制器等）直接访问计算机内存的**技术**，而无需中间经过CPU。
   在标准的（非DMA）数据传输中，数据需要经过下面的路径：设备（如磁盘）-> 设备驱动 -> 内核缓冲区 -> 用户空间 -> 内核缓冲区 -> 设备驱动 -> 网络设备。在这个过程中，数据在内核空间和用户空间之间进行了多次拷贝，这就是所谓的"双拷贝"。
   使用DMA的情况则完全不同。当DMA被使用时，数据可以直接从设备（如磁盘）传输到内存，然后再从内存直接传输到另一个设备（如网络卡），而不需要在内核空间和用户空间之间进行拷贝。因此，DMA可以实现"零拷贝"。

### 0906号

#### 主从延迟
> 从数据库复制和执行主数据库的操作需要一定的时间，导致从数据库的数据比主数据库的数据滞后一些。
##### 优化主从延迟的方法
1. 优化网络连接
2. 提升硬件设备
3. 优化数据库配置：例如增加`innodb_buffer_pool_size
4. 并行复制
5. 分区：当数据库很大的情况

### 0907号

#### Reactor原理
> 事件驱动编程的设计模式

Reactor关键组件
- Reactor：负责事件的分发，监听所有事件源
- Handlers：负责处理程序
- Events：各种输入源（通常是 I/O 操作）触发的事件
- Demultiplexer：系统级别的组件，负责同步阻塞等待所有输入源的事件，然后传递给Reactor

1. 单Reactor单线程：reactor、acceptor和handle的逻辑都由一个线程来执行
2. 单Reactor多线程：reactor、acceptor和handle的逻辑都由一个线程来执行，然后handle负责读取和写回逻辑，具体业务逻辑由worker线程完成（线程池管理）
3. 主-从Reactor多线程：主reactor负责监听事件和连接事件，然后会把连接发送给从reactor，从reactor连接上的后续事件，然后handle负责读取和写回逻辑，具体业务逻辑由worker线程完成（线程池管理）

### 0908号

#### 死锁的排查
1. 日志：每个线程获取和释放锁的时候都记录日志
2. 使用调试工具：如GDB可以在运行时检测死锁
3. 使用静态分析工具：可以在编译器检测出可能导致死锁的代码

#### 内存泄漏的排查
1. 使用智能指针：写代码期
2. 手动检查：看代码期
3. 使用静态分析工具：编译期
4. 使用内存分析工具：运行期
#### 一致性哈希
##### 工作原理：
- 每个服务器用哈希函数映射到哈希环上
- 每个数据也用哈希函数映射到哈希环上
- 每个数据应该存储在顺时针的第一个服务器上

##### 虚拟节点：
> 在一致性哈希的基础上，引入了虚拟节点的概念，以解决数据分布不均衡的问题。

思路：每个真实的服务器节点可以被映射为多个虚拟节点。这些虚拟节点被哈希到哈希环的不同位置，然后数据项被分配给虚拟节点，而不是真实的服务器节点。
例如：4个服务器，你可以为每个服务器创建100个虚拟节点，这样你就有400个虚拟节点分布在哈希环上。当一个新的数据项到来时，你只需要找到哈希环上顺时针遇到的第一个虚拟节点，然后将数据项分配给该虚拟节点对应的真实服务器。
##### 优点：
1. 平衡性：均匀分布数据
2. 单调性：当加入新的服务器时，已经分配的绝大部分数据都还是会映射到原来的服务器中
3. 分散性：当服务器数量变化较大时，也可以保证很好的分布性
4. 负载：能够处理非常大的缓存空间，并且在负载较重的情况下，性能也非常好。
 
##### 缺点：
1. **数据分布不均衡**：如果哈希函数的选择不好或者节点的数量过少，可能仍然会导致数据分布不均匀。
2. **无法保证负载均衡**：如果某些节点的处理能力比其他节点强，那么将会出现负载不均衡的情况。
3. **哈希碰撞**：如果哈希函数的设计不好，可能会导致哈希碰撞，即多个不同的输入被映射到了同一输出，这会导致数据丢失。
##### 优化：
1. 使用更好的哈希函数：解决**数据分布不均衡**、**哈希碰撞**
2. 引入虚拟节点：解决**数据分布不均衡**
3. 考虑服务器的负载能力：给负载能力高的分配多的虚拟节点，负载能力差的分配少的虚拟节点，以解决**无法保证负载均衡**

#### 区分Buffer Cache,Page Cache,CPU Cache

1. CPU Cache：就是我们常说的三级高速缓存，速度分别为1-3、10-20、40-75CPU周期左右。大小分别为几十KB～几百KB、几百KB～几MB、几MB～几十MB左右
2. Page Cache：页缓存，是操作系统读取磁盘数据时使用的缓存
3. Buffer Cache：应用级别缓存，早起Unix和Linux中用于缓存磁盘的块设备I/O，现在已经被统一为Page Cache。在其他上下文中可能指缓存区，例如数据库系统可能会有自己的buffer cache



#### Lambda表达式实现原理
> 当编译器遇到一个lambda表达式时，它会生成一个未命名的类，并且这个类会覆盖函数调用操作符`operator()`。Lambda表达式的主体被转换为在这个`operator()`中的代码。如果lambda表达式捕获了任何变量（无论是按值捕获还是按引用捕获），那么这些变量将被添加为**闭包类型的成员变量**。

样例：
```cpp
int x = 0, x2 = 2;
auto lambda = [x, &x2](int y) { return x - x2 + y; };

// 展开
class __Unnamed {
    int x;
    int& x2;
public:
    __Unnamed(int x, int& x2) : x(x), x2(x2) {}
    int operator()(int y) const { return x - x2 + y; }
};
auto lambda = __Unnamed(x, x2);
```

- 即使两个lambda表达式的捕获列表完全相同，它们的参数列表不同，那么它们也会被编译器转换为两个不同的闭包类。
  
#### RAII原理
> RAII，全称Resource Acquisition Is Initialization，是C++中的一种编程技巧。

- RAII的主要思想是将资源的生命周期与对象的生命周期绑定在一起
- 当对象被创建时，它会获取所需的资源（比如打开一个文件、申请内存等）
- 并在对象被销毁时释放这些资源
- RAII的一个典型应用是智能指针
### 0909号

### 0910号

### 0911号

### 0912号

### 0913号

### 0914号

### 0915号

### 0916号

### 0917号

### 0918号

### 0919号

### 0920号

### 0921号

### 0922号

### 0923号

### 0924号

### 0925号

### 0926号
1. 足下科技一面（面试）
2. 整理了10个项目题目回答（项目）
3. Spark python找乱码问题（实习）

### 0927号
1. 快手音视频C++一面（面试）（挂）
2. 配置Java AFS（实习）


### 0928号

### 0929号

### 0930号
