## Redis
### 1.Zset的跳表
- 就是层级链表（logN）
- 相比于红黑树：支持并发，实现简单，不支持区间查找，空间消耗大
### 2.过期健的淘汰策略
- 定时删除：有利内存
- 定期删除：随机看参数
- 惰性删除：有利CPU
- 惰性删除+定期删除：Mixed
### 3.持久化
- AOF
- RDB
- AOF+RDB 
### 4.为什么单线程还是快
- 大部分操作在内存完成
- 没有进程切换开销
-  I/O 多路复用机制
- CPU不是瓶颈，可能在网络带宽or内存
## HTTP
### 1.HTTP版本区别
- HTTP/0.9：仅支持GET
- HTTP/1.0：支持POST等新特性，引入Header
- HTTP/1.1：支持长链接，管线化
- HTTP/2.0：引入二进制协议，头部压缩(HPACK)，服务器推送，并发传输(Stream)
- HTTP/3.0：使用新的QUIC(无队头阻塞，更快建立连接，连接迁移)，默认TLS1.3加密
### 2.状态码
- 1xx：中间状态
- 2xx：成功
- 3xx：重定向
- 4xx：客户端错误
- 5xx：服务端错误
### 3. SSL/TLS
1. client(Client Hello)：**TLS版本号**，**密码套件列表**，**随机数1**
2. server(Server Hello)：**TLS版本号**，**随机数2**，**密码套件**（密钥交换算法，签名算法，对称加密算法，摘要算法），**CA证书**（Certificate Signature，公钥，有效时间，用途，持有者信息，CA机构信息）
  - 客户端用约定的Hash算法获取证书Hash值H1，然后用公钥解密CS得到Hash值H2，如果H1等于H2就可以确保证书的完整性
  - 然后通过证书依赖向上找到根证书，然后在本地找是否有这个根证书的依赖
3. client(Client Key Exchange)：公钥加密后的**PMS(Pre-Master Secret)**
  -  服务器拿到加密后的PMS，用私钥解密出PMS，然后用约定好的PSK算出**MS(Master Secret)**
4. client(Change Cipher Spec)：告诉服务器接下来开始加密通话(使用MS)
5. client(Encrypted Handshake Message/Finished)：验证加密通信是否可用

### 4.RSA算法
> DES的软件实现比RSA快100倍，硬件实现快1000~10 000倍，实际应用中通常结合起来用。RSA还有一个缺点就是不支持**前向保密**，ECDHE密钥协商算法解决了这个问题

**执行步骤：**
- 选择两个大素数p,q
- $n = p * q$
- $z = (p - 1) * (q - 1)$
- $z = n - p - q + 1,n > z$
- 取$e < n$, 使$gcd(e, z) = 1$
- 求$d$使$ed \equiv 1 \pmod z$
- 公钥:`(n,e)`,密钥:`(n,d)`
- $m^{e*d} \equiv m^{e*d \pmod z} \equiv m^1 \pmod n$ (这里详细证明就不写了)

**加密m：**
- A（公钥），B（有公钥，私钥）
- A，求出$c \equiv m^e \pmod n$, (用公钥加密)， 发送c
- B得到c，求出$m \equiv c^d \pmod n$,(用私钥钥解密)


### 5.cookie和session


## TCP/UDP
### 1.三次挥手
- c：SYN
- s：SYN+1，ACK
- c：ACK
### 2.四次握手
- c：FIN
- s：ACK
- s：FIN
- c：ACK
### 3.拥塞控制
- 慢启动
- 快速恢复
- 拥塞避免
### 4.QUIC
- 快速建立连接：采用0-RTT连接建立方式，可以在一次往返时延内建立连接
- 支持多路复用：可以在一个连接上传输多个数据流
- 支持移动设备：QUIC对移动设备的网络环境进行优化，降低网络丢包率和延迟
- 集成可靠性和安全性：流控制，拥塞控制，TLS等



## IP
### 1.ARP
- 源MAC地址是什么：发送ARP请求的主机的MAC地址
- 目的MAC地址是什么：请求的目标主机的MAC地址
- 怎么找到目的MAC地址：当目标主机接收到ARP请求时，它会检查请求中的IP地址是否与自己的IP地址匹配。如果匹配，它将向发送主机发送一个ARP响应，响应包含目标主机的MAC地址。

## MySQL
### 1.MVCC
- 多版本并发控制(Multi-Version Concurrency Control)
- 为每一个事务创建一个Read View，反映事务启动时的状态
- 避免了锁的使用
- 使用回滚日志(undo log)实现

### 2.回表和覆盖索引
- 先定位主键，然后定位资源就是回表
- 覆盖锁引是指无需回表直接就可以得到所需资源

### 3.前缀索引
- 类似于tire树，一个字母一个节点

### 4.B+树
- 数据全部在叶子节点
- 叶子节点上的数据使用双链表相连
- 树的高度低，减少I/O

### 5.死锁
>死锁的4个必要条件：互斥、占有且等待、不可强占用、循环等待 
- 开启死锁检测
- 设置事务等待锁超时时间
- 资源有序法来防止死锁

### 6.间隙锁(Gap Lock)
- Gap Lock之间没有互斥关系

### 7.快照读/当前读
>两种读取数据的方式，快照读是读取事务开始时的快照数据，当前读是读取当前最新数据，当前读可以分为共享锁读和排他锁读

### 8.如何用 Redis 实现分布式锁的？
- SET命令中有个NX参数可以满足key不存在时插入
  - 如果key插入成功，表示加锁成功
  - 反之，表示加锁失败
- 在SET命令执行时加上EX/PX选项，设置过期时间
- 给每个客户端设置一个唯一值来区别客户端

```MySQL
SET lock_key 8848 NX PX 10000 
```
> 给客户端8848设置一个10s的锁


## 操作系统
### 1.段页式存储特点，用到了什么寄存器
### 2. kill一个线程发生了什么
### 3.什么是软中断，什么是硬中断
### 4.进程间通信
### 5.进程调度策略
### 6.DMA(Direct Memory Access)
> 在进行I/O设备和内存的数据传输时候，数据搬运的工作全部交给DMA控制器，CPU不再参与任何与数据搬运相关事情

### 7.零拷贝(Zero-copy)
> 没有通过CPU来拷贝数据，所有数据都是DMA来进行传输到
```cpp
// mmap + write 
buf = mmap(file, len);
write(sockfd, buf, len);

// sendfile
sendfile(file, sockfd, offset, len); //offset 偏移量
```
>使用sendfile少一次系统调用，少两次上下文切换，但是还是有三次拷贝：
1. DMA拷贝：磁盘 -> 缓存区
2. CPU拷贝：缓存区 -> socket缓存区
3. DMA拷贝：socket缓冲区 -> 网卡
如果使用SG-DMA技术，那么2、3步可以由SG-DMA控制器将内核缓存区拷贝到网卡中，从而实现零拷贝


## C++
### 1.关键字
1. static：静态变量，作用域为所在文件夹
2. virtual：用于实现多态，虚函数可以被子类函数改写
3. new/delete：用于动态内存管理
4. extern：用于声明外部变量或函数，表示该变量或函数定义在其他文件中
5. explicit：用于显式声明构造函数，防止隐式类型转换。
6. volatile：表示该变量是易变的，可能被意外修改，需要在每次使用时重新获取。
7. noexcept：函数说明符，用于指示一个函数不会引发异常
8. constexpr：指示一个表达式可以在编译时计算出结果
9. override：用于标识一个成员函数将覆盖基类的虚函数
10. final：用于防止类的派生类重载虚函数

### 2.折叠表达式
> C++17新引入的语法
```cpp
template<typename... Args>
auto sum(int op, Args... args) noexcept
{
    if(op == 0) return (args + ...);
    else if(op == 1) return (args - ...);
    
    return (args, ...);
}

int main()
{
    std::cout << sum(0, 1, 2, 3, 4, 5) << std::endl; // 输出15
    std::cout << sum(1, 1, 2, 3, 4, 5) << std::endl; // 输出3, 1 - 2 + 3 - 4 + 5
    std::cout << sum(1000, 1, 2, 3, 4, 5) << std::endl; // 输出5，逗号表达式语法
    return 0;
}
```
### 3.亡值

### 4.虚函数怎么实现，怎么获取虚函数地址

### 5.RAII机制
### 6.C++动态多态的实现
> 动态多态是通过虚函数来实现的，基类中的函数被声明为虚函数就可以被子类改写，通过基类指针指向实际的子类类型确定函数的实际类型被称为动态多态
> C++11中override可以保证子类函数是一个改写函数。
### 7.C++设计模式
### 8.C++的四种类型转换
### 9.C++的内存模型





## Kafka
### 1.如何保证不会重复消费
### 2.消费组结构
### 3.零拷贝
### 4.滚动策略
### 5.高可靠性

## Kubernetes


## 分布式系统
### 1.CAP